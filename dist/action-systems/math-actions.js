class e{static async perform(a,t,r,s){return this[a.action]!=null?await this[a.action](a,t,r,s):await this.do_math_api(a,t,r,s)}static async add(a,t,r,s){return await this.do_math(a,t,r,s,(i,c)=>i+c)}static async subtract(a,t,r,s){return await this.do_math(a,t,r,s,(i,c)=>i-c)}static async multiply(a,t,r,s){return await this.do_math(a,t,r,s,(i,c)=>i*c)}static async divide(a,t,r,s){return await this.do_math(a,t,r,s,(i,c)=>i/c)}static async do_math(a,t,r,s,i){const c=await crs.process.getValue(a.args.value1,t,r,s),l=await crs.process.getValue(a.args.value2,t,r,s),u=i(c,l);return a.args.target!=null&&await crs.process.setValue(a.args.target,u,t,r,s),u}static async do_math_api(a,t,r,s){const i=[],c=Array.isArray(a.args.value)?a.args.value:[a.args.value];for(let u of c){const n=await crs.process.getValue(u,t,r,s);i.push(n)}const l=Math[a.action]?.(...i);return a.args.target!=null&&await crs.process.setValue(a.args.target,l,t,r,s),l}static async normalize(a,t,r,s){const i=await crs.process.getValue(a.args.value,t,r,s),c=await crs.process.getValue(a.args.min,t,r,s),l=await crs.process.getValue(a.args.max,t,r,s),u=(i-c)/(l-c);return a.args.target!=null&&await crs.process.setValue(a.args.target,u,t,r,s),u}}crs.intent.math=e;export{e as MathActions};
