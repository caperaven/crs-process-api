class r{#o;#e=[];#t={};#s={};#r=[];#i;get options(){return this.#i}get providers(){return this.#t}get valueProcessors(){return this.#r}get managers(){return this.#s}get styleImports(){return this.#e}constructor(t,s){this.#o=t,this.#i=s||{}}async dispose(){for(let t of Object.keys(this.#t))await this.#t[t].dispose();for(let t of Object.keys(this.#s))await this.#s[t].dispose();this.#t=null,this.#s=null,this.#o=null,this.#r=null,this.#e=null,this.#i=0}async register(t){const s=new t(this);s.isManager==!0?(this.#s[s.key]=s,s.valueProcessor==!0&&this.#r.push(s)):this.#t[s.key]=s}async load(t){for(let s of t||[])await this.register((await import(s)).default)}async init(){for(const s of Object.keys(this.#s))await this.#s[s].reset?.();const t=Object.keys(this.schema);for(let s of t)s!=this.#i.root&&this.#s[s]!=null&&await this.#s[s].initialize(this.schema[s])}async processStyleImports(t){if(this.#e.length>0){const s=[];this.#e.forEach(e=>s.push(`@import "${e}";`)),t=`<style>${s.join(`
`)};</style>${t}`}return t}}export{r as BaseParser};
